# Rate Limiting — Защита от избыточных запросов

## Что сделано

### 1. Frontend оптимизация
- ✅ Увеличены интервалы polling с 30/60 сек → 2 минуты
- ✅ Добавлена остановка polling при неактивной вкладке
- ✅ Автоматическое возобновление при возврате

**Файлы:**
- `src/hooks/useUnreadMessages.tsx`
- `src/hooks/useNewOrders.tsx`
- `src/hooks/useNewReviews.tsx`

### 2. Backend защита
- ✅ Создана утилита `/backend/rate-limiter` для проверки лимитов
- ✅ Добавлен rate limiting в функцию `/backend/messages` (40 req/min)
- ✅ Добавлен rate limiting в функцию `/backend/reviews` (60 req/min)

**Как работает:**
- Хранение счётчиков в PostgreSQL таблице `rate_limits`
- Скользящее окно (sliding window) для подсчёта запросов
- Автоматическая очистка старых записей
- HTTP 429 при превышении лимита с заголовком `Retry-After`

## Экономика

### Было (до оптимизации)
- useUnreadMessages: 120 запросов/час/пользователь
- useNewOrders: 120 запросов/час/массажист
- useNewReviews: 60 запросов/час/пользователь
- **Итого:** ~300 запросов/час на активного пользователя

### Стало (после оптимизации)
- useUnreadMessages: 30 запросов/час
- useNewOrders: 30 запросов/час
- useNewReviews: 30 запросов/час
- **Итого:** ~75 запросов/час на активного пользователя
- При неактивной вкладке: 0 запросов

### Экономия
**Снижение расходов в 4 раза** (75% экономия)

## Лимиты по функциям

| Функция | Лимит | Окно | Защита |
|---------|-------|------|--------|
| `messages` GET | 40 req | 60 сек | По user_id |
| `reviews` GET | 60 req | 60 сек | По IP адресу |

## Рекомендации по монетизации

### 1. Freemium модель
- Бесплатный тариф: 50 запросов/час
- Pro тариф: без лимитов + WebSocket

### 2. Pay-per-use
- Используем существующую систему баланса
- 1 рубль = 1000 запросов

### 3. Комиссия с букингов
- 5-10% комиссия с каждой записи
- Самый органичный вариант для marketplace

## Следующие шаги

1. **WebSocket для real-time** (замена polling)
   - Снизит нагрузку ещё в 10 раз
   - Мгновенные уведомления

2. **Self-host Google Fonts**
   - Экономия на внешних CDN запросах

3. **Кэширование на уровне API**
   - Redis/Memory cache для популярных запросов

4. **Мониторинг**
   - Dashboard с метриками использования
   - Алерты при превышении порогов
